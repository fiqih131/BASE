// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";

interface ISubmission {
    struct Haiku {
        address author;
        string line1;
        string line2;
        string line3;
    }

    function mintHaiku(
        string memory _line1,
        string memory _line2,
        string memory _line3
    ) external;

    function counter() external view returns (uint256);

    function shareHaiku(uint256 _id, address _to) external;

    function getMySharedHaikus() external view returns (Haiku[] memory);
}

contract HaikuNFT is ERC721, ISubmission {
    Haiku[] public haikus; // index = tokenId

    // sharedHaikus[address][id] = true
    mapping(address => mapping(uint256 => bool)) public sharedHaikus;

    uint256 public nextId;

    error HaikuNotUnique();
    error NotYourHaiku(uint256 id);
    error NoHaikusShared();

    constructor() ERC721("HaikuNFT", "HAIKU") {
        // push dummy haiku at index 0 (so ids start at 1)
        haikus.push(Haiku(address(0), "", "", ""));
        nextId = 1;
    }

    function counter() external view override returns (uint256) {
        return nextId;
    }

    function mintHaiku(
        string memory _line1,
        string memory _line2,
        string memory _line3
    ) external override {
        // Unicité : comparer chaque ligne avec toutes les lignes déjà stockées
        for (uint256 i = 1; i < haikus.length; i++) {
            Haiku memory existing = haikus[i];
            if (
                keccak256(bytes(existing.line1)) == keccak256(bytes(_line1)) ||
                keccak256(bytes(existing.line2)) == keccak256(bytes(_line1)) ||
                keccak256(bytes(existing.line3)) == keccak256(bytes(_line1)) ||
                keccak256(bytes(existing.line1)) == keccak256(bytes(_line2)) ||
                keccak256(bytes(existing.line2)) == keccak256(bytes(_line2)) ||
                keccak256(bytes(existing.line3)) == keccak256(bytes(_line2)) ||
                keccak256(bytes(existing.line1)) == keccak256(bytes(_line3)) ||
                keccak256(bytes(existing.line2)) == keccak256(bytes(_line3)) ||
                keccak256(bytes(existing.line3)) == keccak256(bytes(_line3))
            ) {
                revert HaikuNotUnique();
            }
        }

        uint256 id = nextId;
        _safeMint(msg.sender, id);
        haikus.push(Haiku(msg.sender, _line1, _line2, _line3));

        nextId++;
    }

    function shareHaiku(uint256 _id, address _to) external override {
        require(_id > 0 && _id < nextId, "Invalid haiku ID");

        if (ownerOf(_id) != msg.sender) {
            revert NotYourHaiku(_id);
        }

        sharedHaikus[_to][_id] = true;
    }

    function getMySharedHaikus()
        external
        view
        override
        returns (Haiku[] memory)
    {
        uint256 count;
        for (uint256 i = 1; i < nextId; i++) {
            if (sharedHaikus[msg.sender][i]) {
                count++;
            }
        }

        if (count == 0) revert NoHaikusShared();

        Haiku[] memory result = new Haiku[](count);
        uint256 idx;
        for (uint256 i = 1; i < nextId; i++) {
            if (sharedHaikus[msg.sender][i]) {
                result[idx] = haikus[i];
                idx++;
            }
        }
        return result;
    }
}
